module booth_multiplier(
    input  logic clk,
    input  logic rst,
    input  logic signed [15:0] M,
    input  logic signed [15:0] Q,
    output logic signed [31:0] product
);
    logic signed [15:0] accum;
    logic [15:0] M_bar;
    logic Q_minusone;
    logic signed [32:0] booth_reg;
    logic signed [15:0] Q_reg;
    int count;

    always_ff @(posedge clk or posedge rst) begin
        M_bar = (~M) + 1;
    end

    always_ff @(posedge clk or posedge rst) begin
        if (rst) begin
            product     <= 0;
            accum       <= 0;
            Q_minusone  <= 0;
            booth_reg   <= 0;
            Q_reg       <= Q;
            count       <= 16;
        end
        else if (count > 0) begin
            case ({Q_reg[0], Q_minusone})
                2'b01: accum = accum + M;
                2'b10: accum = accum + M_bar;
                default: ;
            endcase
            booth_reg   = {accum, Q_reg, Q_minusone};
            booth_reg   = $signed(booth_reg) >>> 1;
            accum       = booth_reg[32:17];
            Q_reg       = booth_reg[16:1];
            Q_minusone  = booth_reg[0];
            count       = count - 1;
        end
        else begin
            product = {accum, Q_reg};
        end
    end
endmodule
`timescale 1ns/1ps

module tb_booth_multiplier;

    logic clk;
    logic rst;
    logic signed [15:0] M;
    logic signed [15:0] Q;
    logic signed [31:0] product;
     

    booth_multiplier dut (
        .clk(clk),
        .rst(rst),
        .M(M),
        .Q(Q),
        .product(product)
    );

    always #5 clk = ~clk;

    initial begin
        clk = 0;
        rst = 1;
        M   = 7;
        Q   = -3;

        #100 rst = 0;
        #200;
        $display("M=7, Q=-3 -> Product=%0d", $signed(product));

        #50 $finish;
    end
endmodule
